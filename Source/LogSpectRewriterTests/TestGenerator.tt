<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <auto-generated>
//     This code was generated by a T4 template.
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>

namespace LogSpectRewriterTests
{
    using System;
    using LogSpectRewriterTests.Infrastructure;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
<#
foreach (TestSet testSet in ReadDirectory(Path.GetDirectoryName(Host.TemplateFile)))
{
#>

    [TestClass]
    public class <#= testSet.Name #>
    {<#
    foreach (Test test in testSet.Tests)
    {
        if (test.Warnings != null && test.Output != null)
        {
#>

        [TestMethod]
        public void <#= test.Name #>()
        {
            const string ClassDefinitions = @"<#= test.Code.Trim().Replace("\"", "\"\"") #>";
            const string ExpectedWarnings = @"<#= test.Warnings.Replace("\"", "\"\"") #>";
            const string TestCode = @"<#= test.Run.Trim().Replace("\"", "\"\"") #>";
            const string ExpectedOutput = @"<#= test.Output.Replace("\"", "\"\"") #>";

            CodeRunner.CompileRewriteAndRun(ClassDefinitions, ExpectedWarnings, TestCode, ExpectedOutput);
        }
<#
        }
        else if (test.Warnings != null)
        {
#>

        [TestMethod]
        public void <#= test.Name #>()
        {
            const string ClassDefinitions = @"<#= test.Code.Trim().Replace("\"", "\"\"") #>";
            const string ExpectedWarnings = @"<#= test.Warnings.Replace("\"", "\"\"") #>";

            CodeRunner.CompileAndRewrite(ClassDefinitions, ExpectedWarnings);
        }
<#
        }
        else if (test.Output != null)
        {
#>

        [TestMethod]
        public void <#= test.Name #>()
        {
            const string ClassDefinitions = @"<#= test.Code.Trim().Replace("\"", "\"\"") #>";
            const string TestCode = @"<#= test.Run.Trim().Replace("\"", "\"\"") #>";
            const string ExpectedOutput = @"<#= test.Output.Replace("\"", "\"\"") #>";

            CodeRunner.CompileRewriteAndRun(ClassDefinitions, TestCode, ExpectedOutput);
        }
<#
        }
    }
#>
    }
<#
}
#>
}
<#+

private class CodeBlock
{
    public string Label { get; set; }

    public string Syntax { get; set; }

    public string Code { get; set; }
}

private class TestSet
{
    public string Name { get; set; }

    public IList<Test> Tests { get; set; }
}

private class Test
{
    public string Name { get; set; }

    public string Code { get; set; }

    public string Run { get; set; }

    public string Output { get; set; }

    public string Warnings { get; set; }
}

private IList<TestSet> ReadDirectory(string directoryPath)
{
    return
        Directory.GetFiles(directoryPath, "*.md")
            .Select(x => new TestSet { Name = Path.GetFileNameWithoutExtension(x), Tests = ParseMarkdown(File.ReadAllText(x)) })
            .ToList();
}

private IList<Test> ParseMarkdown(string markdown)
{
    int i = 0;
    List<Test> tests = new List<Test>();
    string[] lines = markdown.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);

    while (true)
    {
        string name = ReadTestName(lines, ref i);
        if (name == null)
        {
            break;
        }

        CodeBlock codeBlock;
        CodeBlock warningBlock = null;
        CodeBlock runBlock;
        CodeBlock outputBlock = null;
        CodeBlock tmp;

        codeBlock = ReadCodeBlock(lines, ref i);

        tmp = ReadCodeBlock(lines, ref i);
        if (tmp.Label == "Warnings")
        {
            warningBlock = tmp;
            runBlock = ReadCodeBlock(lines, ref i);
            if (runBlock != null)
            {
                outputBlock = ReadCodeBlock(lines, ref i);
            }
        }
        else
        {
            runBlock = tmp;
            outputBlock = ReadCodeBlock(lines, ref i);
        }

        tests.Add(new Test
            {
                Name = name,
                Code = codeBlock.Code,
                Warnings = warningBlock == null ? null : warningBlock.Code,
                Run = runBlock == null ? null : runBlock.Code,
                Output = outputBlock == null ? null : outputBlock.Code
            });
    }

    return tests;
}

private string ReadTestName(string[] lines, ref int i)
{
    for (; i < lines.Length; i++)
    {
        if (lines[i].StartsWith("### "))
        {
            return lines[i++].Substring(4);
        }
    }
    
    return null;
}

private CodeBlock ReadCodeBlock(string[] lines, ref int i)
{
    string label = null;
    for (; i < lines.Length; i++)
    {
        if (lines[i].StartsWith("###"))
        {
            return null;
        }

        if (lines[i].StartsWith("```"))
        {
            break;
        }

        if (lines[i].EndsWith(":"))
        {
            label = lines[i].Substring(0, lines[i].Length - 1);
            i++;
            break;
        }
    }

    string syntax = null;
    for (; i < lines.Length; i++)
    {
        if (lines[i].StartsWith("```"))
        {
            if (lines[i].Length > 3)
            {
                syntax = lines[i].Substring(3);
            }

            i++;
            break;
        }
    }

    StringBuilder code = new StringBuilder();
    for (; i < lines.Length; i++)
    {
        if (lines[i] == "```")
        {
            i++;
            break;
        }

        code.AppendLine(lines[i]);
    }

    return new CodeBlock { Label = label, Syntax = syntax, Code = code.ToString() };
}
#>